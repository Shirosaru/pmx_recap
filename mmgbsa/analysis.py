import pandas as pd
import os

def read_mmpbsa_results(filepath):
    """Reads _MMPBSA_results.dat and returns a pandas DataFrame."""
    try:
        # The file usually has a few header lines starting with # or empty lines
        # and then a header row. We need to find where the actual data starts.
        with open(filepath, 'r') as f:
            lines = f.readlines()
        
        data_start_line = 0
        header = []
        for i, line in enumerate(lines):
            if not line.strip().startswith('#') and line.strip(): # Find first non-comment, non-empty line
                # Assume the line before the data block is the header if it looks like one
                if i > 0 and 'Total' in lines[i-1] and 'Std. Dev.' in lines[i-1]:
                    # This heuristic might need adjustment based on gmx_MMPBSA version
                    header_line = lines[i-1].strip()
                    # Clean up header line (remove extra spaces, 'Std. Dev.' parts)
                    header = [h.strip() for h in header_line.split('  ') if h.strip() and not 'Std. Dev.' in h]
                    header.append('Std. Dev. Total') # Add Std. Dev. for Total
                    data_start_line = i
                    break
                elif "DELTAGB" in line or "TOTAL" in line: # More general header check
                    header_line = line.strip()
                    header = [h.strip() for h in header_line.split() if h.strip() and h != 'TOTAL']
                    header.append('TOTAL') # Main Total energy
                    header.append('TOTAL_SD') # Standard Deviation of Total
                    data_start_line = i + 1 # Data starts on the next line
                    break

        if not header:
            # Fallback if the above heuristics fail, try to read as a fixed width file
            # or manual inspection is needed.
            print(f"WARNING: Could not reliably parse header for {filepath}. Attempting generic read.")
            # Simplest fallback: skip a few lines and let pandas guess
            df = pd.read_csv(filepath, comment='#', delim_whitespace=True)
            return df
        
        # Read the data section using the identified header
        data_lines = lines[data_start_line:]
        
        # Manually parse data lines because multiple spaces can mess with delim_whitespace
        parsed_data = []
        for line in data_lines:
            if line.strip() and not line.strip().startswith('#'):
                parts = line.split()
                # Assuming first value is usually frame/type, and then values
                if len(parts) >= len(header): # Basic check to ensure enough columns
                    parsed_data.append([float(p) if i > 0 else p for i, p in enumerate(parts)]) # Convert to float
                else:
                    print(f"Skipping malformed data line: {line.strip()}")
        
        df = pd.DataFrame(parsed_data, columns=header[:len(parsed_data[0])]) # Trim header if too long
        return df

    except Exception as e:
        print(f"Error reading {filepath}: {e}")
        return None

if __name__ == "__main__":
    # Example usage for WT_run_auto results
    wt_results_file = os.path.join(WT_RUN_DIR, "FINAL_RESULTS_MMPBSA.dat") # Or whatever gmx_MMPBSA names it
    # gmx_MMPBSA typically creates a file like "_MMPBSA_results.dat" or "FINAL_RESULTS_MMPBSA.dat"
    # Check the actual output directory for the exact filename.
    # From common usage, it's often 'FINAL_RESULTS_MMPBSA.dat' or 'MMPBSA_per_res_total.dat' for decomposition.
    
    # Let's assume the main summary is FINAL_RESULTS_MMPBSA.dat
    # You might need to check your actual output for the exact name.
    
    # Common result file names generated by gmx_MMPBSA
    potential_result_files = [
        "FINAL_RESULTS_MMPBSA.dat",
        "_MMPBSA_results.dat",
        "MMPBSA_per_res_total.dat" # For per-residue decomposition
    ]

    print("\n--- WT Results ---")
    wt_found_file = False
    for fname in potential_result_files:
        full_path = os.path.join(WT_RUN_DIR, fname)
        if os.path.exists(full_path):
            print(f"Found WT result file: {full_path}")
            df_wt = read_mmpbsa_results(full_path)
            if df_wt is not None:
                print(df_wt)
                wt_found_file = True
                # You can add more analysis here, e.g., print specific totals
                if 'TOTAL' in df_wt.columns:
                    print(f"WT Total binding energy (kcal/mol): {df_wt['TOTAL'].iloc[0]}")
                    if 'TOTAL_SD' in df_wt.columns:
                        print(f"WT Total binding energy Std. Dev.: {df_wt['TOTAL_SD'].iloc[0]}")
                print("-" * 30)
            break # Stop after finding the first one
    if not wt_found_file:
        print(f"No common gmx_MMPBSA result file found in {WT_RUN_DIR}. Please check the directory manually.")


    print("\n--- MT Results ---")
    mt_found_file = False
    for fname in potential_result_files:
        full_path = os.path.join(MT_RUN_DIR, fname)
        if os.path.exists(full_path):
            print(f"Found MT result file: {full_path}")
            df_mt = read_mmpbsa_results(full_path)
            if df_mt is not None:
                print(df_mt)
                mt_found_file = True
                if 'TOTAL' in df_mt.columns:
                    print(f"MT Total binding energy (kcal/mol): {df_mt['TOTAL'].iloc[0]}")
                    if 'TOTAL_SD' in df_mt.columns:
                        print(f"MT Total binding energy Std. Dev.: {df_mt['TOTAL_SD'].iloc[0]}")
                print("-" * 30)
            break
    if not mt_found_file:
        print(f"No common gmx_MMPBSA result file found in {MT_RUN_DIR}. Please check the directory manually.")

    # Calculate Delta Delta G
    if wt_found_file and mt_found_file and 'TOTAL' in df_wt.columns and 'TOTAL' in df_mt.columns:
        delta_g_wt = df_wt['TOTAL'].iloc[0]
        delta_g_mt = df_mt['TOTAL'].iloc[0]
        delta_delta_g = delta_g_mt - delta_g_wt
        print(f"\n--- Delta Delta G Calculation ---")
        print(f"ΔG_WT: {delta_g_wt:.2f} kcal/mol")
        print(f"ΔG_MT: {delta_g_mt:.2f} kcal/mol")
        print(f"ΔΔG (ΔG_MT - ΔG_WT): {delta_delta_g:.2f} kcal/mol")
        print("A positive ΔΔG typically indicates that the mutation destabilizes the binding.")
        print("A negative ΔΔG typically indicates that the mutation stabilizes the binding.")
    else:
        print("\nCould not calculate Delta Delta G. Ensure both WT and MT results are available and parsed correctly.")